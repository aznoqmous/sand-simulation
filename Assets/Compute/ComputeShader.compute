#pragma kernel CSMain

struct Particle {
    float2 position;
    float2 real_position;
    float2 direction;
    float speed;
    int type;
    float idle_time;
};

struct ParticleType {
    float4 color;
    int movement_type;
    float dispersion;
    int is_solid;
};

float2 DIR_UP = float2(0.0, 1.0);
float2 DIR_DOWN = float2(0.0, -1.0);
float2 DIR_LEFT = float2(-1.0, 0.0);
float2 DIR_RIGHT = float2(1.0, 0.0);

float Size;
float Time;
float DeltaTime;
float Gravity;
bool MouseDown;
bool DrawBounds;
int MouseType;
int BrushSize;
float2 ChunkPosition;
float2 MousePosition;
float IdleTime;
int Step;

RWTexture2D<float4> Result;
RWTexture2D<float4> ColliderTexture;

RWStructuredBuffer<Particle> Particles;
RWStructuredBuffer<int> States;

RWStructuredBuffer<Particle> LeftChunkParticles;
RWStructuredBuffer<Particle> TopChunkParticles;
RWStructuredBuffer<Particle> BottomChunkParticles;
RWStructuredBuffer<Particle> RightChunkParticles;

StructuredBuffer<ParticleType> Types;

void increment_solid_particles_count(){
    InterlockedAdd(States[5], 1);
}
void increment_particles_count(){
    InterlockedAdd(States[6], 1);
}

float2 unity_gradientNoise_dir(float2 p)
{
    p = p % 289;
    float x = (34 * p.x + 1) * p.x % 289 + p.y;
    x = (34 * x + 1) * x % 289;
    x = frac(x / 41) * 2 - 1;
    return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}

float unity_gradientNoise(float2 p)
{
    float2 ip = floor(p);
    float2 fp = frac(p);
    float d00 = dot(unity_gradientNoise_dir(ip), fp);
    float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
    float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
    float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
    fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
    return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
}

float2 floor2(float2 movement){
    return float2(floor(movement.x), floor(movement.y));
}

float2 get_movement(float2 mov){
    if(abs(mov.x) > abs(mov.y)) return abs(mov.x) >= 1 ? float2(sign(mov.x),  0.0) : float2(0.0, 0.0);
    return abs(mov.y) >= 1 ? float2(0.0, sign(mov.y)) : float2(0.0, 0.0);
}

float fract(float x)
{
    return x / floor(x);
}

float rand(float2 c){
    return fract(sin(dot(c.xy, float2(12.9898 + Time, 78.233))) * 43758.5453);
}

void draw(float2 position, float4 color){
    Result[position] = color;
}

int position_to_id(float2 position){
    return position.x * Size + position.y;
}
int position_to_id(float x, float y){
    return x * Size + y;
}

void update_particle(float2 position, Particle p)
{
    if(position.y < 0.0) BottomChunkParticles[position_to_id(position.x, (Size - 1.0))] = p;
    else if(position.y > Size - 1.0) TopChunkParticles[position_to_id(position.x, 0.0)] = p;
    else if(position.x < 0.0) LeftChunkParticles[position_to_id((Size - 1.0), position.y)] = p;
    else if(position.x > Size - 1.0) RightChunkParticles[position_to_id(0, position.y)] = p;
    else Particles[position.x * Size + position.y] = p;
}


Particle get_particle(float2 position){
    if(position.y < 0.0) return BottomChunkParticles[position_to_id(position.x, (Size - 1.0))];
    if(position.y > Size - 1.0) return TopChunkParticles[position_to_id(position.x, 0.0)];
    if(position.x < 0.0) return LeftChunkParticles[position_to_id((Size - 1.0), position.y)];
    if(position.x > Size - 1.0) return RightChunkParticles[position_to_id(0, position.y)];
    return Particles[position.x * Size + position.y];
}
bool is_idle(Particle p){
    return p.idle_time >= IdleTime;
}
bool is_idle(float2 pos){
    return is_idle(get_particle(pos));
}

bool is_empty(float2 position){
    return get_particle(position).type == 0;
}

void erase_particle(Particle p){
    Result[p.position] = float4(0.0, 0.0, 0.0, 0.0);
}

float get_noise(float2 input){
    return unity_gradientNoise(input) * 0.5 + unity_gradientNoise(input / 3.5) * 0.5;
}

void draw_particle(Particle p){
    Result[p.position] = float4(0.0, 0.0, 0.0, 0.0);
    if(p.type == 0) return;
    
    float4 color = Types[p.type].color;
    // if(is_idle(p)){
    //     Result[p.position] = float4(color.xyz, 0.5);
    //     return;
    // }
    
    float noise = 1.0;
    if(p.type == 1) // dirt
    {
        if(is_empty(p.position + float2(0.0, 2.0))) color = float4(0.0, 1.0, 0.2, 1.0);
        noise = get_noise((ChunkPosition * Size + p.position) / 2.0);
    }
    else if(p.type == 3) { // water
        noise = get_noise((ChunkPosition * Size + p.position) / 2.0 + float2(Time, Time));
        color.w = 0.5;
    }
    else {
        noise = get_noise((ChunkPosition * Size + p.position) / 2.0);
    }
    Result[p.position] = color * (float4(1.0, 1.0, 1.0, 1.0) * (noise * 0.6 + 1.0));

    //Result[p.position] = float4(p.speed, abs(p.direction.x), abs(p.direction.y), 1.0);
}

ParticleType get_type(Particle p){
    return Types[p.type];
}
ParticleType get_type(float2 position){
    return Types[get_particle(position).type];
}

void wake_particle_chunk(float2 position){
    if(position.x < 0.0) InterlockedAdd(States[1], 1);
    else if(position.y > Size - 1.0) InterlockedAdd(States[2], 1);
    else if(position.x > Size - 1.0) InterlockedAdd(States[3], 1);
    else if(position.y < 0.0) InterlockedAdd(States[4], 1);
    else InterlockedAdd(States[0], 1);
}

void wake_particle(float2 position){
    Particle p = get_particle(position);
    if(p.type == 0 || get_type(p).movement_type == 0) return;
    p.idle_time = 0;
    wake_particle_chunk(position);
    update_particle(position, p);
}

void wake_neighbors(float2 position){
    wake_particle(position + float2(0, -1));
    wake_particle(position + float2(0, 1));
    wake_particle(position + float2(-1, 0));
    wake_particle(position + float2(1, 0));
}

void move_particle(inout Particle particle, float2 movement){
    float2 targetPosition = particle.position + movement;
    float2 originalPosition = particle.position;
    int targetId = targetPosition.x * Size + targetPosition.y;
    int currentId = particle.position.x * Size + particle.position.y;

    wake_particle(targetPosition);

    Particle targetParticle = Particles[targetId];
    erase_particle(particle);
    if(targetPosition.y < 0.0){
        targetPosition.y = Size - 1.0;
        targetId = position_to_id(targetPosition);
        targetParticle = BottomChunkParticles[targetId];
        particle.position = targetParticle.position;
        particle.real_position = particle.position;
        BottomChunkParticles[targetId] = particle;
    }
    else if(targetPosition.y > Size - 1.0){
        targetPosition.y = 0.0;
        targetId = position_to_id(targetPosition);
        targetParticle = TopChunkParticles[targetId];
        particle.position = targetParticle.position;
        particle.real_position = particle.position;
        TopChunkParticles[targetId] = particle;
    }
    else if(targetPosition.x < 0.0){
        targetPosition.x = Size - 1.0;
        targetId = position_to_id(targetPosition);
        targetParticle = LeftChunkParticles[targetId];
        particle.position = targetParticle.position;
        particle.real_position = particle.position;
        LeftChunkParticles[targetId] = particle;
    }
    else if(targetPosition.x > Size - 1.0){
        targetPosition.x = 0.0;
        targetId = position_to_id(targetPosition);
        targetParticle = RightChunkParticles[targetId];
        particle.position = targetParticle.position;
        particle.real_position = particle.position;
        RightChunkParticles[targetId] = particle;
    }
    else {
        particle.position = targetPosition;
        particle.real_position = particle.position;
        Particles[targetId] = particle;
        draw_particle(particle);
    }

    targetParticle.position = originalPosition;
    targetParticle.real_position = originalPosition;
    Particles[currentId] = targetParticle;

}



void move_toward(inout Particle p, float2 direction, float speed=5.0){
    p.direction += direction * DeltaTime * speed;
    p.direction = normalize(p.direction);
    p.speed += speed * DeltaTime;
    Particles[position_to_id(p.position)] = p;
}

void handle_particle_movement(inout Particle p){
    p.speed *= 1 - DeltaTime;

    if(p.speed < 0.1) p.idle_time += DeltaTime;
    else {
        p.real_position += p.direction * p.speed * DeltaTime * 10.0;
        wake_particle(p.position);
        wake_neighbors(p.position);
    }

    update_particle(p.position, p);
    
    if(is_idle(p)) return;

    float2 mov = get_movement(p.real_position - p.position);
    
    if(mov.x == 0.0 && mov.y == 0.0) return;
    
    if(!is_empty(p.position + mov)){
        p.real_position = p.position;
        p.direction = float2(0.0, 0.0);
        p.speed = 0.0;
        update_particle(p.position, p);
        return;
    }
    
    move_particle(p, mov);
}

bool handle_sand(inout Particle p)
{
    ParticleType t = get_type(p);

    if(is_empty(p.position + float2(0.0, -1.0))) {
        move_toward(p, float2(0.0, -1.0), Gravity);
        return true;
    }
    else {
        float sandDispersion = get_type(p).dispersion;
        if (is_empty(p.position + float2(1, 0)) && is_empty(p.position + float2(1, -1)))
        {
            move_toward(p, float2(1.0, 0.0), sandDispersion);
            return true;
        }
        else if (is_empty(p.position + float2(-1, 0)) && is_empty(p.position + float2(-1, -1)))
        {
            move_toward(p, float2(-1.0, 0.0), sandDispersion);
            return true;
        }
    }

    return false;
}

bool handle_water(inout Particle p){

    if(!handle_sand(p)){
        float waterDispersion = get_type(p).dispersion;
        if (int(rand(p.position) * 100000.0) % 2 == 0 && is_empty(p.position + float2(1, 0)))
        {
            move_toward(p, float2(1.0, 0.0), waterDispersion);
            return true;
        }
        else if (is_empty(p.position + float2(-1, 0)))
        {
            move_toward(p, float2(-1.0, 0.0), waterDispersion);
            return true;
        }
        else if (is_empty(p.position + float2(1, 0)))
        {
            move_toward(p, float2(1.0, 0.0), waterDispersion);
            return true;
        }
    }

    return false;
}

void InitChunkStates(){
    States[0] = 0; // particles - self
    States[1] = 0; // particles - left
    States[2] = 0; // particles - top
    States[3] = 0; // particles - right
    States[4] = 0; // particles - bottom

    States[5] = 0; // collision - self
    // States[6] = 0; // collision - left
    // States[7] = 0; // collision - top
    // States[8] = 0; // collision - right
    // States[9] = 0; // collision - bottom
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Alternate particle direction on each frame
    uint3 current_step = id.xyz;
    if(Step == 1 ) current_step = uint3(Size - current_step.x, Size - current_step.y, current_step.z);
    if(Step == 2 ) current_step = uint3(current_step.x, Size - current_step.y, current_step.z);
    if(Step == 3 ) current_step = uint3(Size - current_step.x, current_step.y, current_step.z);

    Particle p = Particles[current_step.x * Size + current_step.y];
    ColliderTexture[p.position] = float4(0.0, 0.0, 0.0, 0.0);
    
    if(distance(MousePosition, p.position) < BrushSize && MouseDown){
        Particles[p.position.x * Size + p.position.y].type = MouseType;
        Particles[p.position.x * Size + p.position.y].idle_time = 0;
        return;
    }

    if(Particles[p.position.x * Size + p.position.y].type == 0) {
        erase_particle(p);

        /**
        * Show chunk bounds
        **/
        if(DrawBounds){
            //Result[current_step.xy] = float4(1,1,1,0.1);
            if(current_step.x == 0) Result[current_step.xy] = float4(1,1,1,1);
            if(current_step.x >= (Size - 1.0)) Result[current_step.xy] = float4(1,1,1,1);
            if(current_step.y == 0) Result[current_step.xy] = float4(1,1,1,1);
            if(current_step.y >= (Size - 1.0)) Result[current_step.xy] = float4(1,1,1,1);
        }
        return;
    }


    draw_particle(p);
    increment_particles_count();

    if(is_idle(p)){
        if(get_type(p).is_solid == 1) {
            ColliderTexture[p.position] = float4(1.0, 1.0, 1.0, 1.0);
            increment_solid_particles_count();
        }
        return;
    }


    if(get_type(p).movement_type == 0){
        p.idle_time = IdleTime;
        update_particle(p.position, p);
    }
    if(get_type(p).movement_type == 1){
        handle_sand(p);
    }
    if(get_type(p).movement_type == 2){
        handle_water(p);
    }
    handle_particle_movement(p);
}

