// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float Size;
float Time;
bool MouseDown;
int MouseType;
float2 MousePosition;
struct Particle {
    float2 position;
    int type;
};

RWStructuredBuffer<Particle> Particles;

RWStructuredBuffer<Particle> LeftChunkParticles;
RWStructuredBuffer<Particle> TopChunkParticles;
RWStructuredBuffer<Particle> BottomChunkParticles;
RWStructuredBuffer<Particle> RightChunkParticles;

struct ParticleType {
    float4 color;
    int movementType;
};
RWStructuredBuffer<ParticleType> Types;

float2 unity_gradientNoise_dir(float2 p)
{
    p = p % 289;
    float x = (34 * p.x + 1) * p.x % 289 + p.y;
    x = (34 * x + 1) * x % 289;
    x = frac(x / 41) * 2 - 1;
    return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}

float unity_gradientNoise(float2 p)
{
    float2 ip = floor(p);
    float2 fp = frac(p);
    float d00 = dot(unity_gradientNoise_dir(ip), fp);
    float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
    float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
    float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
    fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
    return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
}

float fract(float x)
{
    return x / floor(x);
}

float rand(float2 c){
    return fract(sin(dot(c.xy, float2(12.9898 + Time, 78.233))) * 43758.5453);
}

void draw(float2 position, float4 color){
    Result[position] = color;
}

void eraseParticle(Particle p){
    Result[p.position] = float4(0.0, 0.0, 0.0, 0.0);
}

void drawParticle(Particle p){
    Result[p.position] = float4(0.0, 0.0, 0.0, 0.0);
    if(p.type == 0) return;

    float4 color = Types[p.type].color;
    Result[p.position] = color + unity_gradientNoise(p.position / 2.0) / 5.0;
}

int positionToId(float2 position){
    return position.x * Size + position.y;
}
int positionToId(float x, float y){
    return x * Size + y;
}

Particle getParticle(float2 position){
    if(position.y < 0.0) return BottomChunkParticles[positionToId(position.x, (Size - 1.0))];
    if(position.y > Size - 1.0) return TopChunkParticles[positionToId(position.x, 0.0)];
    if(position.x < 0.0) return LeftChunkParticles[positionToId((Size - 1.0), position.y)];
    if(position.x > Size - 1.0) return RightChunkParticles[positionToId(0, position.y)];
    return Particles[position.x * Size + position.y];
}

bool isEmpty(float2 position){
    return getParticle(position).type == 0;
}



void moveParticle(inout Particle particle, float2 movement){
    float2 targetPosition = particle.position + movement;
    float2 originalPosition = particle.position;
    int targetId = targetPosition.x * Size + targetPosition.y;
    int currentId = particle.position.x * Size + particle.position.y;

    Particle targetParticle = Particles[targetId];
    eraseParticle(particle);
    if(targetPosition.y < 0.0){
        targetPosition.y = Size - 1.0;
        targetId = positionToId(targetPosition);
        targetParticle = BottomChunkParticles[targetId];
        particle.position = targetParticle.position;
        BottomChunkParticles[targetId] = particle;
    }
    else if(targetPosition.y > Size - 1.0){
        targetPosition.y = 0.0;
        targetId = positionToId(targetPosition);
        targetParticle = TopChunkParticles[targetId];
        particle.position = targetParticle.position;
        TopChunkParticles[targetId] = particle;
    }
    else if(targetPosition.x < 0.0){
        targetPosition.x = Size - 1.0;
        targetId = positionToId(targetPosition);
        targetParticle = LeftChunkParticles[targetId];
        particle.position = targetParticle.position;
        LeftChunkParticles[targetId] = particle;
    }
    else if(targetPosition.x > Size - 1.0){
        targetPosition.x = 0.0;
        targetId = positionToId(targetPosition);
        targetParticle = RightChunkParticles[targetId];
        particle.position = targetParticle.position;
        RightChunkParticles[targetId] = particle;
    }
    else {
        Particles[targetId] = particle;
        Particles[targetId].position = targetPosition;
        drawParticle(particle);
    }

    Particles[currentId] = targetParticle;
    Particles[currentId].position = originalPosition;

}

bool handleSand(inout Particle p)
{
    if(isEmpty(p.position + float2(0.0, -1.0))){
        moveParticle(p, float2(0.0, -1.0));
        return true;
    }
    else {
        if (isEmpty(p.position + float2(1, 0)) && isEmpty(p.position + float2(1, -1)))
        {
            moveParticle(p, float2(1.0, 0.0));
            return true;
        }
        else if (isEmpty(p.position + float2(-1, 0)) && isEmpty(p.position + float2(-1, -1)))
        {
            moveParticle(p, float2(-1.0, 0.0));
            return true;
        }
    }
    return false;
}

bool handleWater(inout Particle p){


    if(!handleSand(p)){
        if (int(rand(p.position) * 100000.0) % 2 == 0 && isEmpty(p.position + float2(1, 0)))
        {
            moveParticle(p, float2(1.0, 0.0));
            return true;
        }
        else if (isEmpty(p.position + float2(-1, 0)))
        {
            moveParticle(p, float2(-1.0, 0.0));
            return true;
        }
        else if (isEmpty(p.position + float2(1, 0)))
        {
            moveParticle(p, float2(1.0, 0.0));
            return true;
        }
    }

    return false;
}
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);

    Particle p = Particles[id.x * Size + id.y];
    
    if(distance(MousePosition, p.position) < 5.0 && MouseDown){
        Particles[p.position.x * Size + p.position.y].type = MouseType;
        return;
    }

    if(Particles[p.position.x * Size + p.position.y].type == 0) {
        eraseParticle(p);

        /**
        * Show chunk bounds
        if(id.x == 0) Result[id.xy] = float4(1,1,1,1);
        if(id.x >= (Size - 1.0)) Result[id.xy] = float4(1,1,1,1);
        if(id.y == 0) Result[id.xy] = float4(1,1,1,1);
        if(id.y >= (Size - 1.0)) Result[id.xy] = float4(1,1,1,1);
        **/
        return;
    }

    drawParticle(p);
    //eraseParticle(p);
    if(Types[p.type].movementType == 1){
        handleSand(p);
    }
    if(Types[p.type].movementType == 2){
        handleWater(p);
    }
}

